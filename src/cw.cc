/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307  USA
 */

#include <vector>
#include <algorithm>

#include "ns3/core-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/network-module.h"
#include "ns3/applications-module.h"
#include "ns3/wifi-module.h"
#include "ns3/mobility-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
#include "ns3/propagation-loss-model.h"
#include "ns3/aodv-module.h"
using namespace ns3;

uint32_t bytesTotal;
uint32_t packetsReceived;
uint32_t Node0Pending = 0;
uint32_t Node1SendAck = 0;
uint32_t Node1Pending = 0;
uint32_t Node2SendAck = 0;
uint16_t Pkt_no_last_seen_by_node2  = 0;
uint16_t Pkt_no_being_sent_by_node1 = 0;
uint16_t Pkt_no_last_seen_by_node1  = 0;
uint16_t Pkt_no_being_sent_by_node0 = 1;

uint32_t node0_capacity = 3;
/// Lastest email generated by node 1 but not yet send
uint16_t node0_head = 0;
/// Earliest email generated by node 1 but not yet sent
uint16_t node0_tail = 0;
// Last email generated by Node 0
uint16_t globalcounter = 1;
uint16_t isbufferempty = 1;
NS_LOG_COMPONENT_DEFINE("FinalProject");


uint16_t node1_head          = 0;
uint16_t node1_tail          = 0;
uint16_t node1_globalcounter = 0;
uint16_t node1_isbufferempty = 1;

// (II.e) Priority Queue holding all emails received by Node 1
std::vector<uint16_t> node2_received_emails;


//----Experiment parameters

double distance_between_node0_node2 = 10000; //x-axis distance
double distance_between_node0_node1 = 3;     //y-axis distance

Time duration = Seconds(560);


//--------------------Custom header code begin------------//

class MyHeader : public Header
{
public:
	// new methods
	void SetData(uint16_t data);
	uint16_t GetData(void);
	void SetPacketType(uint16_t data);
	uint16_t GetPacketType(void);
	void Setisbufferempty(uint16_t data);
	uint16_t Getisbufferempty(void);
	void Sethead(uint16_t data);
	uint16_t Gethead(void);
	void Settail(uint16_t data);
	uint16_t Gettail(void);
	void Setglobalcounter(uint16_t data);
	uint16_t Getglobalcounter(void);

	// new method needed
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;

	// overridden from Header
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize(Buffer::Iterator start) const;
	virtual uint32_t Deserialize(Buffer::Iterator start);
	virtual void Print(std::ostream& os) const;

private:
	uint16_t m_data;
	uint16_t m_packettype;
	uint16_t m_isbufferempty;
	uint16_t m_head;
	uint16_t m_tail;
	uint16_t m_globalcounter;
};

//Implementation of public members of class MyHeader
void
MyHeader::SetData(uint16_t data)
{
	m_data = data;
}


uint16_t
MyHeader::GetData(void)
{
	return m_data;
}


void
MyHeader::SetPacketType(uint16_t data)
{
	m_packettype = data;
}


uint16_t
MyHeader::GetPacketType(void)
{
	return m_packettype;
}


void
MyHeader::Setisbufferempty(uint16_t data)
{
	m_isbufferempty = data;
}


uint16_t
MyHeader::Getisbufferempty(void)
{
	return m_isbufferempty;
}


void
MyHeader::Sethead(uint16_t data)
{
	m_head = data;
}


uint16_t
MyHeader::Gethead(void)
{
	return m_head;
}


void
MyHeader::Settail(uint16_t data)
{
	m_tail = data;
}


uint16_t
MyHeader::Gettail(void)
{
	return m_tail;
}


void
MyHeader::Setglobalcounter(uint16_t data)
{
	m_globalcounter = data;
}


uint16_t
MyHeader::Getglobalcounter(void)
{
	return m_globalcounter;
}


uint32_t
MyHeader::GetSerializedSize(void) const
{
	// two bytes of data to store
//  return 2;
//  return 4;
	return 12;
}


void
MyHeader::Serialize(Buffer::Iterator start) const
{
	start.WriteHtonU16(m_data);
	start.WriteHtonU16(m_packettype);
	start.WriteHtonU16(m_isbufferempty);
	start.WriteHtonU16(m_head);
	start.WriteHtonU16(m_tail);
	start.WriteHtonU16(m_globalcounter);
}


uint32_t
MyHeader::Deserialize(Buffer::Iterator start)
{
	m_data          = start.ReadNtohU16();
	m_packettype    = start.ReadNtohU16();
	m_isbufferempty = start.ReadNtohU16();
	m_head          = start.ReadNtohU16();
	m_tail          = start.ReadNtohU16();
	m_globalcounter = start.ReadNtohU16();
	return 12;
}


void
MyHeader::Print(std::ostream& os) const
{
	os << m_data;
}


TypeId
MyHeader::GetTypeId(void)
{
	static TypeId tid = TypeId("ns3::MyHeader")
	                       .SetParent<Header> ()
	                       .AddConstructor<MyHeader> ()
	;

	return tid;
}


TypeId
MyHeader::GetInstanceTypeId(void) const
{
	return GetTypeId();
}


//--------------------Custom header code end------------//

// This function keeps track of the position of a moving node using
// (x,y) coordinates
void CourseChangeSink(Ptr<OutputStreamWrapper> stream,
                      std::string              context,
                      Ptr<const MobilityModel> model)
{
	Vector position = model->GetPosition();

	// NS_LOG_UNCOND(Simulator::Now().GetSeconds() <<
	//               " Course change! x = " << position.x << ", y = "
	//                                             << position.y);
	*stream->GetStream() << Simulator::Now().GetSeconds()
	                     << "\t" << position.x
	                     << "\t" << position.y << std::endl;
}


//---Higher level code for Node 0 BEGIN

static void Node0DataGen()
{
//      NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
	// << " Node 0 generating data.");
	if (isbufferempty == 1)
	{
//              NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
		// << " Node 0 buffer is empty.");
		node0_head    = globalcounter;
		node0_tail    = globalcounter;
		isbufferempty = 0;
	}
	else
	{
		// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
		// << " Node 0 buffer is NOT empty.");
		// two ends included
		int inbuffer = node0_head - node0_tail + 1;
		if (inbuffer >= (signed int)node0_capacity)
		{
			// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
			// << " Node 0 buffer is full - must remove elements");
			++node0_tail;
			++node0_head;
		}
		else
		{
			// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
			// 	<< " Node 0 buffer is NOT full.");
			++node0_head;
		}
	}
	++globalcounter;
	Simulator::Schedule(Seconds(1.00), &Node0DataGen);
}


/// Node 1 sends a data packet. Repeats every 0.25 seconds (4 times/s)
static void Node0SendPacket(Ptr<Socket> socket, uint32_t pktSize)
{
	Ptr<Packet> p = Create<Packet> ();
	MyHeader    XXheader;

	if (isbufferempty == 0)
	{
		// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
		// 	<< " Node 0 sending a packet.");
		XXheader.SetPacketType(1);                  // 1 for data
		XXheader.Setisbufferempty(isbufferempty);   // header fields
		XXheader.Sethead(node0_head);               // header fields
		XXheader.Settail(node0_tail);               // header fields
		XXheader.Setglobalcounter(globalcounter);   // header fields
		p->AddHeader(XXheader);
		socket->Send(p);
	}
	else
	{
		// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
		// << " Node 0 has nothing to send.");
	}
	Simulator::Schedule(Seconds(0.25), &Node0SendPacket, socket,
	                    pktSize);
}


static void Node0ReceivePacket(Ptr<Socket> socket)
{
	// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
	//               << " Node 0 received a packet.");
	isbufferempty = 1;
}


//---Higher level code for node 0 END



//---Higher level code for node 1 BEGIN

//Advanced declaration
static void Node1SendPacket(Ptr<Socket> socket, uint32_t pktSize);

static void Node1AckLoop(Ptr<Socket> socket, Ptr<Socket> socket2,
                         uint32_t pktSize)
{
	if (Node1SendAck == 1)
	{
		// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
		//               << " Node 1 sending an ACK.");
		Node1SendAck = 0;
		socket->Send(Create<Packet> (pktSize));
		Node1Pending = 1;
		Simulator::Schedule(Seconds(0.0001), &Node1SendPacket,
		                    socket2, pktSize);
	}
	Simulator::Schedule(Seconds(0.01), &Node1AckLoop, socket,
	                    socket2, pktSize);
}


static void Node1ReceivePacket(Ptr<Socket> socket)
{
	// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
	// << " Node 1 received a packet. UNIFIED receiver.");

	MyHeader    header;
	uint16_t    type_of_packet;
	Ptr<Packet> packet;

	packet = socket->Recv();
	packet->RemoveHeader(header);
	type_of_packet             = header.GetPacketType();
	Pkt_no_being_sent_by_node0 = header.Getglobalcounter();
	if (type_of_packet == 1)             //data
	{
		if (Pkt_no_last_seen_by_node1 < Pkt_no_being_sent_by_node0)
		{
			// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
			//               << " The packet received by 1 is"
			//               << " a *UNIQUE* DATA packet.");
			Pkt_no_last_seen_by_node1  = Pkt_no_being_sent_by_node0;
			Pkt_no_being_sent_by_node1 = Pkt_no_last_seen_by_node1;
			Node1SendAck = 1;
			// strip packet contents and transfer contents to
			// variables
			// header fields follow
			node1_isbufferempty = header.Getisbufferempty();
			node1_head          = header.Gethead();
			// (II.e) Keep older emails
			node1_tail = std::min(header.Gettail(),
			                      node1_tail);
			node1_globalcounter = header.Getglobalcounter();
		}
	}
	else
	{
		// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
		// 	<< " The packet received by 1 is an ACK packet.");
		Node1Pending = 0;
	}
}


static void StopMobileNode(Ptr<Node> node)
{
	Ptr<ConstantVelocityMobilityModel> velocityModel =
		node->GetObject<ConstantVelocityMobilityModel>();

	velocityModel->SetVelocity(Vector(0, 0, 0));
}


/// Node 1 sends a data packet. Repeats every 0.25 seconds
static void Node1SendPacket(Ptr<Socket> socket, uint32_t pktSize)
{
	Ptr<Packet> p = Create<Packet> ();
	MyHeader    XXheader;

	if (Node1Pending == 1)
	{
		// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
		// << "Node 1 sending a packet.");
		XXheader.SetPacketType(1);                      // 1 for data
		XXheader.Setisbufferempty(node1_isbufferempty); // hdr fields
		XXheader.Sethead(node1_head);                   // hdr fields
		XXheader.Settail(node1_tail);                   // hdr fields
		XXheader.Setglobalcounter(node1_globalcounter); // hdr fields
		p->AddHeader(XXheader);
		socket->Send(p);
		Simulator::Schedule(Seconds(0.25), &Node1SendPacket, socket,
		                    pktSize);
	}
}


//---Higher level code for node 1 END


//---Higher level code for node 2 BEGIN

static void Node2ReceivePacket(Ptr<Socket> socket)
{
	Ptr<Packet> packet;
	MyHeader    header;

	packet = socket->Recv();
	packet->RemoveHeader(header);

	uint16_t
	    // receivedpacket_isbufferempty = header.Getisbufferempty(),
	    receivedpacket_head          = header.Gethead(),
	    receivedpacket_tail          = header.Gettail(),
	    receivedpacket_globalcounter = header.Getglobalcounter();

	if (Pkt_no_last_seen_by_node2 < receivedpacket_globalcounter)
	{
		Pkt_no_last_seen_by_node2 = receivedpacket_globalcounter;
		// (II.e) Store emails received by node 2
		if (node2_received_emails.size() == 0)
		{
			// never received any packets before
			uint16_t
			& rH = receivedpacket_head,
			& rT = receivedpacket_tail;
			for (int i = rT; i <= rH; ++i)
			{
				node2_received_emails.push_back(i);
			}
		}
		else
		{
			uint16_t
			// received head
			& rT = receivedpacket_tail,
			// received tail
			& rH = receivedpacket_head,
			// current head (i.e. the newest email)
			  H = node2_received_emails.back() + 1;
			for (uint16_t i = std::max(rT, H); i <= rH; ++i)
			{
				node2_received_emails.push_back(i);
				push_heap(node2_received_emails.begin(),
				          node2_received_emails.end());
			}
		}
		// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
		//               << " Node 2 received a packet.");
		// std::cout << "*------------*" << std::endl
		//           << "The value of *isbufferempty* is "
		//           << receivedpacket_isbufferempty << std::endl
		//           << "The value of *head* is "
		//           << receivedpacket_head << std::endl
		//           << "The value of *tail* is "
		//           << receivedpacket_tail << std::endl
		//           << "The value of *globalcounter* is "
		//           << receivedpacket_globalcounter << std::endl
		//     // (II.C) Print The Amount of Packets Received By Node 2
		//           << "Number of emails received by node 2: "
		//           << node2_received_emails.size() << std::endl;
		// std::cout << "*------------*" << std::endl;
		Node2SendAck = 1;
	}
}


static void Node2AckLoop(Ptr<Socket> socket, uint32_t pktSize)
{
	Ptr<Packet> p = Create<Packet> ();
	MyHeader    XXheader;

	if (Node2SendAck == 1)
	{
		// Pkt_no_last_seen_by_node2 = Pkt_no_being_sent_by_node1;
		// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
		//               << " Node 2 sending an ACK.");
		Node2SendAck = 0;
		XXheader.SetPacketType(0);      // 0 for ack
		p->AddHeader(XXheader);
		socket->Send(p);
	}
	Simulator::Schedule(Seconds(0.01), &Node2AckLoop, socket,
	                    pktSize);
}


//---Higher level code for node 2 END

struct Node3Data
{
	static uint16_t Pkt_no_last_seen, Pkt_no_being_sent,
	                head, tail, isbufferempty, globalcounter;
	static uint32_t SendAck, Pending;
};

uint16_t Node3Data::Pkt_no_last_seen  = 0;
uint16_t Node3Data::Pkt_no_being_sent = 0;
uint16_t Node3Data::head          = 0;
uint16_t Node3Data::tail          = 0;
uint16_t Node3Data::globalcounter = 0;
uint16_t Node3Data::isbufferempty = 1;
uint32_t Node3Data::SendAck       = 0;
uint32_t Node3Data::Pending       = 0;

static void Node3ReceivePacket(Ptr<Socket> socket)
{
	// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
	// << " Node 3 received a packet. UNIFIED receiver.");

	MyHeader    header;
	Ptr<Packet> packet = socket->Recv();

	packet->RemoveHeader(header);
	Pkt_no_being_sent_by_node0 = header.Getglobalcounter();
	uint16_t type_of_packet = header.GetPacketType();

	if (type_of_packet == 1)             //data
	{
		if (Node3Data::Pkt_no_last_seen < Pkt_no_being_sent_by_node0)
		{
			// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
			//               << " The packet received by 3 is"
			//               << " a *UNIQUE* DATA packet.");
			Node3Data::Pkt_no_last_seen  = Pkt_no_being_sent_by_node0;
			Node3Data::Pkt_no_being_sent = Node3Data::Pkt_no_last_seen;
			Node3Data::SendAck           = 1;
			// strip packet contents and transfer contents to
			// variables
			// header fields follow
			Node3Data::isbufferempty = header.Getisbufferempty();
			Node3Data::head          = header.Gethead();
			// (II.e) Keep older emails
			Node3Data::tail = std::min(header.Gettail(),
			                           Node3Data::tail);
			Node3Data::globalcounter = header.Getglobalcounter();
		}
	}
	else
	{
		// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
		// 	<< " The packet received by 3 is an ACK packet.");
		Node3Data::Pending = 0;
	}
}


static void Node3SendPacket(Ptr<Socket> socket, uint32_t pktSize)
{
	Ptr<Packet> p = Create<Packet> ();
	MyHeader    XXheader;

	if (Node3Data::Pending == 1)
	{
		// NS_LOG_UNCOND(Simulator::Now ().GetSeconds ()
		// << "Node 3 sending a packet.");
		XXheader.SetPacketType(1);                      // 1 for data
		// setting header field
		XXheader.Setisbufferempty(Node3Data::isbufferempty);
		XXheader.Sethead(Node3Data::head);
		XXheader.Settail(Node3Data::tail);
		XXheader.Setglobalcounter(Node3Data::globalcounter);
		p->AddHeader(XXheader);
		socket->Send(p);
		Simulator::Schedule(Seconds(0.25), &Node3SendPacket, socket,
		                    pktSize);
	}
}


static void Node3AckLoop(Ptr<Socket> socket, Ptr<Socket> socket2,
                         uint32_t pktSize)
{
	if (Node3Data::SendAck == 1)
	{
		// NS_LOG_UNCOND(Simulator::Now().GetSeconds()
		//               << " Node 3 sending an ACK.");
		Node3Data::SendAck = 0;
		socket->Send(Create<Packet> (pktSize));
		Node3Data::Pending = 1;
		Simulator::Schedule(Seconds(0.0001), &Node3SendPacket,
		                    socket2, pktSize);
	}
	Simulator::Schedule(Seconds(0.01), &Node3AckLoop, socket,
	                    socket2, pktSize);
}


//This is the main function
int main(int argc, char *argv[])
{
	// (II.d) Parse command line arguments
	uint32_t    d          = 3;
	uint32_t    node1speed = 20;
	uint32_t    d2         = 250;
	CommandLine args;

	args.AddValue("d", "initial distance of node 0 to node 1", d);
	args.AddValue("node1speed", "speed of node 1", node1speed);
	args.AddValue("d2", "distance of node 1 from node 3", d2);
	args.Parse(argc, argv);

	double      txp = 1.5;        //transmission power dB
	std::string phyMode("DsssRate1Mbps");

	//Set Non-unicastMode rate to unicast mode
	Config::SetDefault(
		"ns3::WifiRemoteStationManager::NonUnicastMode",
		StringValue(phyMode));

	// 1. Create the nodes
	NodeContainer adhocNodes;

	//All 3 nodes are members of adhocNodes
	adhocNodes.Create(4);
	//Node 1 is defined as the mobileNode (i.e., the bus)
	NodeContainer mobileNode = NodeContainer(adhocNodes.Get(1),
	                                         adhocNodes.Get(3));
	// Node 0 and Node 2 are defined as stationaryNodes
	// (i.e., the villages)
	NodeContainer stationaryNodes = NodeContainer(adhocNodes.Get(0),
	                                              adhocNodes.Get(2));

	// 2. Set up physical layer
	WifiHelper wifi;

	//Use 802.11 standard
	wifi.SetStandard(WIFI_PHY_STANDARD_80211b);
	YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();

	//Set up the gain at the receiver (in dB)
	wifiPhy.Set("RxGain", DoubleValue(-10));

	// 3. Set up propagation loss model
	YansWifiChannelHelper wifiChannel;

	//Range propagation loss model
	std::string lossModel = "ns3::RangePropagationLossModel";
	std::string atr1      = "MaxRange";

	// maximum transmission range = 200 m
	wifiChannel.AddPropagationLoss(lossModel, atr1, DoubleValue(200));

	//set up the propagation delay model
	wifiChannel.SetPropagationDelay(
		"ns3::ConstantSpeedPropagationDelayModel");
	wifiPhy.SetChannel(wifiChannel.Create());

	//set up the transmission power
	wifiPhy.Set("TxPowerStart", DoubleValue(txp));
	wifiPhy.Set("TxPowerEnd", DoubleValue(txp));


	// 4. Set up MAC layer and install wireless devices
	NqosWifiMacHelper wifiMac = NqosWifiMacHelper::Default();

	wifi.SetRemoteStationManager(
		"ns3::ConstantRateWifiManager",
		"DataMode", StringValue("DsssRate2Mbps"),
		"ControlMode", StringValue("DsssRate1Mbps"));
	//Set MAC to ad hoc mode
	wifiMac.SetType("ns3::AdhocWifiMac");
	NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac,
	                                          adhocNodes);

	// 5. Set up mobility model for Node 1
	MobilityHelper mobilityMobileNode;

	// (II.A) Set Mobility Model For Constant Velocity of Node 1
	mobilityMobileNode.SetMobilityModel(
		"ns3::ConstantVelocityMobilityModel");

	Ptr<ListPositionAllocator> positionAllocMobileNode =
		CreateObject<ListPositionAllocator> ();

	// 3D coordinates (x,y,z). Use only the x-y plane
	positionAllocMobileNode->Add(Vector(0.0, d, 0.0));
	positionAllocMobileNode->Add(Vector(-static_cast<int>(d2), d, 0.0));
	mobilityMobileNode.SetPositionAllocator(positionAllocMobileNode);

	mobilityMobileNode.Install(mobileNode);

	// (II.A) Set Velocity of Node 1 Using Previous Model
	mobileNode.Get(0)
	   ->GetObject<ConstantVelocityMobilityModel>()
	   ->SetVelocity(Vector(node1speed, 0, 0));
	Simulator::Schedule(
		Seconds(static_cast<double>(distance_between_node0_node2)
		        / static_cast<double>(node1speed)
		        ), &StopMobileNode, mobileNode.Get(0));

	// (II.g) Set Velocity of Node 3
	mobileNode.Get(1)
	   ->GetObject<ConstantVelocityMobilityModel>()
	   ->SetVelocity(Vector(node1speed, 0, 0));
	Simulator::Schedule(
		Seconds(static_cast<double>(d2 + distance_between_node0_node2)
		        / static_cast<double>(node1speed)
		        ), &StopMobileNode, mobileNode.Get(1));

	// 6. Connect trace source to trace sink for Node 1
	std::ostringstream oss;

	oss <<
	    "/NodeList/" << mobileNode.Get(0)->GetId() <<
	    "/$ns3::MobilityModel/CourseChange";

	AsciiTraceHelper         asciiTraceHelper;
	Ptr<OutputStreamWrapper> locationStream =
		asciiTraceHelper.CreateFileStream("Location.txt");

	Config::Connect(oss.str(), MakeBoundCallback(&CourseChangeSink,
	                                             locationStream));

	// 7. Assign positions to Node 0 and Node 2
	MobilityHelper mobilityStaNodes;

	mobilityStaNodes.SetMobilityModel(
		"ns3::ConstantPositionMobilityModel");
	Ptr<ListPositionAllocator> positionAllocStaNodes =
		CreateObject<ListPositionAllocator> ();

	//3D coordinates (x,y,z). Use only the x-y plane
	positionAllocStaNodes->Add(Vector(0.0, 0.0, 0.0));
	//3D coordinates (x,y,z). Use only the x-y plane
	positionAllocStaNodes->Add(Vector(
								   distance_between_node0_node2,
								   0.0, 0.0));
	mobilityStaNodes.SetPositionAllocator(positionAllocStaNodes);
	mobilityStaNodes.Install(stationaryNodes);

	// 8. Set up  the routing protocol (AODV)
	AodvHelper            aodv;
	Ipv4ListRoutingHelper list;
	InternetStackHelper   internet;

	aodv.Set("EnableHello", BooleanValue(false));
	aodv.Set("GratuitousReply", BooleanValue(false));
	aodv.Set("ActiveRouteTimeout", ns3::TimeValue(Seconds(600)));
	list.Add(aodv, 100);

	internet.SetRoutingHelper(list);
	internet.Install(adhocNodes);

	// 9. Assign IP addresses to nodes
	const char        *submask = "255.255.255.0";
	Ipv4AddressHelper address("10.1.1.0", submask);

	Ipv4InterfaceContainer interfaces = address.Assign(devices);

	// 10. Receive sides here; we connect the receiving sockets of
	//  each node to their respective callbacks
	// These callbacks basically define what the node does next upon
	// receiving a packet

	//---node 0's receive side BEGIN
	TypeId tid0 = TypeId::LookupByName(
		"ns3::UdpSocketFactory");
	Ptr<Socket> Node0Recv = Socket::CreateSocket(
		adhocNodes.Get(0), tid0);
	InetSocketAddress local0 = InetSocketAddress(
		Ipv4Address::GetAny(), 9);

	Node0Recv->Bind(local0);

	Node0Recv->SetRecvCallback(MakeCallback(&Node0ReceivePacket));
	//---node 0's receive side END

	//---node 1's receive side BEGIN
	TypeId tid1 = TypeId::LookupByName(
		"ns3::UdpSocketFactory");
	Ptr<Socket> Node1Recv = Socket::CreateSocket(
		adhocNodes.Get(1), tid1);
	InetSocketAddress local1 = InetSocketAddress(
		Ipv4Address::GetAny(), 9);

	Node1Recv->Bind(local1);

	Node1Recv->SetRecvCallback(MakeCallback(&Node1ReceivePacket));
	//---node 1's receive side  END

	//---node 3's receive side BEGIN
	TypeId tid3 = TypeId::LookupByName(
		"ns3::UdpSocketFactory");
	Ptr<Socket> Node3Recv = Socket::CreateSocket(
		adhocNodes.Get(3), tid3);
	InetSocketAddress local3 = InetSocketAddress(
		Ipv4Address::GetAny(), 9);

	Node3Recv->Bind(local3);

	Node3Recv->SetRecvCallback(MakeCallback(&Node3ReceivePacket));
	//---node 3's receive side  END

	//---node 2's receive side BEGIN
	TypeId tid2 = TypeId::LookupByName(
		"ns3::UdpSocketFactory");
	Ptr<Socket> Node2Recv = Socket::CreateSocket(
		adhocNodes.Get(2), tid2);
	InetSocketAddress local2 = InetSocketAddress(
		Ipv4Address::GetAny(), 9);

	Node2Recv->Bind(local2);

	Node2Recv->SetRecvCallback(MakeCallback(&Node2ReceivePacket));
	//---node 2's receive side END


	// 11. Generate traffic
	uint32_t packetSize = 200;             //bytes

	//Start the node 0 ---> node 1 connection
	//fire up Node0SendPacket
	Ptr<Socket> source = Socket::CreateSocket(
		adhocNodes.Get(0), tid0);
	InetSocketAddress SocketAddressof1 = InetSocketAddress(
		interfaces.GetAddress(1, 0), 9);
	InetSocketAddress BroadcastSocketAddr = InetSocketAddress(
		Ipv4Address::GetBroadcast(), 9);

	// InetSocketAddress SocketAddressof3 = InetSocketAddress(
	// 	interfaces.GetAddress(3, 0), 9);

	// uint8_t     addrbytes[4]  = { 10, 1, 1, 0 };
	// Ipv4Address broadcastAddr =
	// 	Ipv4Address::Deserialize(
	// 		addrbytes).GetSubnetDirectedBroadcast(Ipv4Mask(submask));

	// source->Connect(broadcastAddr);
	source->SetAllowBroadcast(true);
	source->Connect(BroadcastSocketAddr);
	Node0Pending = 1;
	Simulator::Schedule(Seconds(0.0001), &Node0SendPacket, source,
	                    packetSize);

	//Start node 1's ACK loop (node 1 ---> node 0, socket 9)
	//We define the node 1---> node 2 connection here as well
	// (socket 9)
	//We need 2 sockets: the first one is used by Node 1 to send ACKs
	// to Node 0
	//The second one is used by Node 1 the send the packet to Node 2
	//Fire up Node1AckLoop
	Ptr<Socket> sourceSocketforNode1 = Socket::CreateSocket(
		adhocNodes.Get(1), tid1);

	InetSocketAddress SocketAddressof0 = InetSocketAddress(
		interfaces.GetAddress(0, 0), 9);

	sourceSocketforNode1->Connect(SocketAddressof0);

	Ptr<Socket> sourceSocketforNode1SECOND = Socket::CreateSocket(
		adhocNodes.Get(1), tid1);
	InetSocketAddress SocketAddressof2 = InetSocketAddress(
		interfaces.GetAddress(2, 0), 9);

	sourceSocketforNode1SECOND->Connect(SocketAddressof2);

	Simulator::Schedule(Seconds(0.0001), &Node1AckLoop,
	                    sourceSocketforNode1,
	                    sourceSocketforNode1SECOND, packetSize);

	//Start node 2's ACK loop (node 2---> node 1, socket 9)
	//Fire up Node2AckLoop
	Ptr<Socket> sourceSocketforNode2 = Socket::CreateSocket(
		adhocNodes.Get(2), tid2);


	sourceSocketforNode2->Connect(SocketAddressof1);
	Simulator::Schedule(Seconds(0.0001), &Node2AckLoop,
	                    sourceSocketforNode2, packetSize);


	// (II.g) Set up socket for Node 3
	// Set up socket to send ACK to N0
	Ptr<Socket> sender_ack_node_3 = Socket::CreateSocket(
		adhocNodes.Get(3), tid3);

	sender_ack_node_3->Connect(SocketAddressof0);

	// Set ip socket to send DATA to N2
	Ptr<Socket> sender_data_node_3 = Socket::CreateSocket(
		adhocNodes.Get(3), tid3);

	sender_data_node_3->Connect(SocketAddressof2);

	Simulator::Schedule(Seconds(0.0001), &Node3AckLoop,
	                    sender_ack_node_3,
	                    sender_data_node_3, packetSize);


	// wifiPhy.EnableAsciiAll(asciiTraceHelper.CreateFileStream (
	// "PacketsContent.txt"));

	Simulator::Schedule(Seconds(0.0001), &Node0DataGen);

	// 12. Run the simulation
	Simulator::Stop(duration);
	Simulator::Run();
	Simulator::Destroy();

	// (II.h) Print relevant csv
	std::cout << d << ',' << d2 << ','
	          << node2_received_emails.size() << '\n';

	return 0;
}
